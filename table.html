<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gyro Tablet — относительный ноль (мёртвая зона + таймаут)</title>
  <style>
    :root { --bg:#0b1020; --fg:#e7ecff; --mut:#8da1c0; --acc:#7bd; }
    body { margin:0; font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--fg); }
    header { padding: 20px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #1c2746;}
    h1 { font-size: 18px; margin:0; color:#bcd2ff; }
    main { padding: 18px; display:grid; gap:16px; grid-template-columns: 1fr; max-width: 960px; margin:0 auto; }
    .card { background: #111937; border: 1px solid #1c2746; border-radius: 14px; padding: 16px; box-shadow: 0 6px 18px rgba(0,0,0,.18); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .grid { display:grid; grid-template-columns: 200px 1fr; gap:8px 14px; }
    button { background:#15214b; color:#d9e6ff; border:1px solid #29407c; padding:10px 14px; border-radius:12px; cursor:pointer;}
    button:hover { background:#1a2a5b; }
    input[type="number"]{ width:110px; padding:8px 10px; border-radius:10px; border:1px solid #304378; background:#0f1736; color:#e7ecff; }
    .ok{color:#94f3c3} .warn{color:#ffd27b} .err{color:#ff8f8f}
    .small{color:var(--mut); font-size: 13px;}
    .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    .pill{padding:6px 10px; border-radius:999px; background:#0f1a3b; border:1px solid #1f2f63; color:#b9caee}
    canvas{display:block; width:100%; height:180px; background:#0c1430; border-radius:10px; border:1px solid #1c2746}
  </style>
</head>
<body>
  <header>
    <h1>Гироскоп (планшет) — относительный ноль по позе</h1>
    <div class="row">
      <span id="https" class="pill small"></span>
      <span id="state" class="pill small">ожидание</span>
    </div>
  </header>
  <main>

    <section class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <button id="start">Старт</button>
          <button id="stop">Стоп</button>
          <button id="reset">Сбросить ноль вручную</button>
        </div>
        <div class="row small">
          <div>Порог (°/с): <input id="th" type="number" value="4" min="0" max="30" step="0.5" title="мёртвая зона — только если ВСЕ оси ниже порога" /></div>
          <div>Таймаут (мс): <input id="to" type="number" value="2000" min="200" max="10000" step="100" title="если нет событий дольше таймаута — нули" /></div>
          <div>EMA α: <input id="ema" type="number" value="0.35" min="0" max="1" step="0.05" title="сглаживание скоростей перед интегрированием" /></div>
        </div>
      </div>
      <div class="grid" style="margin-top:12px">
        <div>Источник данных:</div><div class="mono">DeviceMotion.rotationRate (°/с), интегрируем в углы</div>
        <div>Интервал события (мс):</div><div id="interval" class="mono">—</div>
        <div>Состояние нулевания:</div><div id="zeroState" class="mono small">—</div>
      </div>
      <div class="small" style="margin-top:8px">
        Правило: <b>нули</b>, когда <u>одновременно</u> |ωx|,|ωy|,|ωz| &lt; порога (мёртвая зона), или когда нет событий дольше таймаута.
        В момент нулевания мы фиксируем текущую позу как базовую и дальше считаем углы <b>относительно этой позы</b> (θx/θy/θz).
      </div>
    </section>

    <section class="card">
      <h3 style="margin-top:0">Угловая скорость (после мёртвой зоны)</h3>
      <div class="grid">
        <div>ω<sub>x</sub>:</div><div class="mono"><span id="wx">—</span> °/с</div>
        <div>ω<sub>y</sub>:</div><div class="mono"><span id="wy">—</span> °/с</div>
        <div>ω<sub>z</sub>:</div><div class="mono"><span id="wz">—</span> °/с</div>
      </div>
      <canvas id="plotV"></canvas>
    </section>

    <section class="card">
      <h3 style="margin-top:0">Относительные углы (с нуля)</h3>
      <div class="grid">
        <div>θ<sub>x</sub>:</div><div class="mono"><span id="ax">—</span> °</div>
        <div>θ<sub>y</sub>:</div><div class="mono"><span id="ay">—</span> °</div>
        <div>θ<sub>z</sub>:</div><div class="mono"><span id="az">—</span> °</div>
      </div>
      <canvas id="plotA"></canvas>
      <div class="small" style="margin-top:8px">Замечание: это относительная оценка из интегрированных скоростей, возможен дрейф (это нормально для чистого гироскопа без фьюжна).</div>
    </section>

  </main>

  <script>
    const $ = sel => document.querySelector(sel);
    const httpsEl = $('#https');
    const stateEl = $('#state');
    const intervalEl = $('#interval');
    const zeroStateEl = $('#zeroState');

    const wxEl = $('#wx'), wyEl = $('#wy'), wzEl = $('#wz');
    const axEl = $('#ax'), ayEl = $('#ay'), azEl = $('#az');

    const thEl = $('#th'), toEl = $('#to'), emaEl = $('#ema');
    const plotV = $('#plotV'), ctxV = plotV.getContext('2d');
    const plotA = $('#plotA'), ctxA = plotA.getContext('2d');

    httpsEl.textContent = (location.protocol === 'https:' ? 'HTTPS: ok' : '⚠ Нужен HTTPS для датчиков');

    // EMA for velocities
    let alpha = Number(emaEl.value);
    let vx=null, vy=null, vz=null;
    function ema(prev, val) { return prev==null ? val : (alpha*val + (1-alpha)*prev); }

    // Angle accumulators (relative), degrees
    let ax=0, ay=0, az=0;

    // Plot buffers
    const N = 180;
    const bufV = {x:[], y:[], z:[]}; // deg/s
    const bufA = {x:[], y:[], z:[]}; // deg
    function pushPlot(buf, dx,dy,dz) {
      buf.x.push(dx); buf.y.push(dy); buf.z.push(dz);
      if (buf.x.length>N) { buf.x.shift(); buf.y.shift(); buf.z.shift(); }
    }
    function drawPlot(canvas, ctx, buf, units='') {
      const w = canvas.width = canvas.clientWidth * devicePixelRatio;
      const h = canvas.height = canvas.clientHeight * devicePixelRatio;
      const series = [buf.x, buf.y, buf.z];
      const colors = ['#80bfff','#7fffd4','#ffb3ba'];
      const maxAbs = Math.max(1, ...series.flat().map(v=>Math.abs(v)));
      const kx = w/Math.max(1,series[0].length-1);
      const ky = (h*0.42)/maxAbs;
      ctx.clearRect(0,0,w,h);
      ctx.strokeStyle='#24345e'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();
      series.forEach((s,si)=>{
        ctx.strokeStyle = colors[si]; ctx.lineWidth = 2;
        ctx.beginPath();
        s.forEach((v,i)=>{ const x=i*kx, y=h/2 - v*ky; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
        ctx.stroke();
      });
    }

    let lastTs = 0;
    let lastUpdateId = 0; // increments on each motion event
    let timer = null;
    let running = false;

    function zeroNow(reason) {
      // Zero velocities (display) and reset relative angles to 0
      wxEl.textContent = '0.00'; wyEl.textContent = '0.00'; wzEl.textContent = '0.00';
      ax = ay = az = 0;
      axEl.textContent = '0.0'; ayEl.textContent = '0.0'; azEl.textContent = '0.0';
      pushPlot(bufV, 0,0,0); pushPlot(bufA, 0,0,0);
      drawPlot(plotV, ctxV, bufV); drawPlot(plotA, ctxA, bufA);
      zeroStateEl.textContent = 'нулевание: ' + reason;
    }

    function handleMotion(e) {
      const rr = e.rotationRate || {};
      const now = performance.now();
      const dtms = (e.interval!=null ? e.interval : (lastTs>0 ? (now-lastTs) : 0)); // ms
      const dt = Math.max(0, dtms) / 1000; // seconds
      lastTs = now;
      intervalEl.textContent = (dtms||0).toFixed(0);

      // EMA smoothing (deg/s)
      let x = rr.beta ?? 0;   // X
      let y = rr.gamma ?? 0;  // Y
      let z = rr.alpha ?? 0;  // Z

      vx = ema(vx, x);
      vy = ema(vy, y);
      vz = ema(vz, z);

      const TH = Math.max(0, Number(thEl.value || 0)); // deg/s
      const allBelow = (Math.abs(vx) < TH) && (Math.abs(vy) < TH) && (Math.abs(vz) < TH);

      if (allBelow) {
        // Deadband: freeze angles at 0 and show zeros
        zeroNow('мёртвая зона (все оси < '+TH.toFixed(2)+'°/с)');
      } else {
        // Show velocities
        wxEl.textContent = vx.toFixed(2);
        wyEl.textContent = vy.toFixed(2);
        wzEl.textContent = vz.toFixed(2);
        pushPlot(bufV, vx, vy, vz);
        drawPlot(plotV, ctxV, bufV);

        // Integrate to relative angles only when NOT in deadband
        if (dt > 0 && isFinite(dt)) {
          ax += vx * dt;
          ay += vy * dt;
          az += vz * dt;
        }
        axEl.textContent = ax.toFixed(1);
        ayEl.textContent = ay.toFixed(1);
        azEl.textContent = az.toFixed(1);
        pushPlot(bufA, ax, ay, az);
        drawPlot(plotA, ctxA, bufA);
        zeroStateEl.textContent = '—';
      }

      // mark update
      lastUpdateId++;
    }

    function start() {
      if (running) return;
      running = true;
      alpha = Number(emaEl.value);

      const needPerm = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function');
      const afterPerm = () => {
        window.addEventListener('devicemotion', handleMotion, { passive: true });
        stateEl.textContent = 'работает'; stateEl.className = 'pill small ok';

        // timeout loop: zero if no events for TO ms
        let seenId = lastUpdateId;
        const loop = () => {
          if (!running) return;
          const TO = Math.max(200, Number(toEl.value || 2000));
          if (lastUpdateId === seenId) {
            if (lastTs>0 && (performance.now() - lastTs) >= TO) {
              zeroNow('таймаут '+TO+' мс');
            }
          } else {
            seenId = lastUpdateId;
          }
          timer = setTimeout(loop, 200);
        };
        loop();
      };

      if (needPerm) {
        DeviceMotionEvent.requestPermission().then(res => {
          if (res !== 'granted') { stateEl.textContent = 'доступ отклонён'; stateEl.className='pill small err'; running=false; return; }
          afterPerm();
        }).catch(err => { stateEl.textContent = 'ошибка: '+err; stateEl.className='pill small err'; running=false; });
      } else {
        afterPerm();
      }
    }

    function stop() {
      running = false;
      try { window.removeEventListener('devicemotion', handleMotion); } catch {}
      try { clearTimeout(timer); } catch {}
      stateEl.textContent = 'остановлено'; stateEl.className = 'pill small warn';
    }

    function manualReset() {
      zeroNow('ручной сброс');
    }

    $('#start').addEventListener('click', start);
    $('#stop').addEventListener('click', stop);
    $('#reset').addEventListener('click', manualReset);
    emaEl.addEventListener('change', ()=>{ alpha = Number(emaEl.value||0.35); });

    // initial draw
    drawPlot(plotV, ctxV, bufV);
    drawPlot(plotA, ctxA, bufA);
  </script>
</body>
</html>
